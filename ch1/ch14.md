---
jupytext:
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.11.5
kernelspec:
  display_name: Bash
  language: bash
  name: bash
---
```{code-cell} bash
:tags: [remove-input]
cd ../home/ch1/my-project
```

# 1.4 Merging Branches
In this section, we'll see how to integrate work from `feature` back into `main`.

## Types of Merges
The two most common merge strategies are fast-forward and three-way merges:
- Fast-forward merge: This merge strategy is used when the target branch can be updated to point to the commit of the source branch without needing to create a new commit.
- Three-way merge: A three-way merge is used when the two branches have diverged and a new commit is required to reconcile the differences.

### Fast-forward merge
Let's first understand visually how a fast-forward merge of the `feature` branch into `main` would look like by comparing the current state of the repository with the state after the merge.

This is how the repository looks like now:

```{mermaid}
flowchart RL
    C2((C2)) --> C1((C1))
    C3((C3)) --> C2
    main --> C2
    feature --> C3
    HEAD{HEAD} --> feature
```

How can we incorporate the changes from `feature` into `main`? If we look at the commit history, we can see that `main` is behind `feature` by one commit. To update `main` with the changes from `feature`, we can simply move the `main` pointer to the same commit as `feature`. This is possible whenever you can update a branch to match another by advancing its pointer through the commit history until it reaches the same commit. This process is known as a 'fast-forward' because it involves moving the pointer forward to the commit of the other branch without creating a new merge commit.

So after the fast-forward merge, the repository would look like this:

```{mermaid}
flowchart RL
    C2((C2)) --> C1((C1))
    C3((C3)) --> C2
    main --> C3
    feature --> C3
    HEAD{HEAD} --> main
```

```{admonition} What to notice
:class: hint
- Since `main` was behind `feature` by one commit, the `main` pointer was simply moved to the same commit as `feature` and now it points to `C3`.
- `feature` still points to `C3`.
- `HEAD` now points to `main` since in order to do the merge we had to switch first to `main`.
```

Now that we understand what a fast-forward merge is, let's see how to do it in Git. To perform a fast-forward merge, first switch to the branch you want to merge into, and then merge the other branch into it using `git merge <branch-name>`. For example, to merge `feature` into `main`:

```{code-cell} bash
git switch main
git merge feature
```

```{code-cell} bash
git status
git log
```

We see that all the changes that we discussed in the diagram have been made. The `main` branch now points to the same commit as `feature`, and the `feature` branch still points to the same commit. The `HEAD` pointer is now pointing to `main`.

## Exercise: Switching and Committing

Switching branches may change the working directory, especially if they point to different commits.

```{code-cell} bash
git switch feature
touch file2.txt
echo -n "This is file 2." >> file2.txt
echo -en "\nThis is the fourth line." >> file1.txt
git add .
git commit -m "Add file2 and modify file1"
git switch main
```

```{admonition} What to notice
:class: hint
The working directory content changes when switching branches.
```

Git prevents loss of work by disallowing branch switching with uncommitted changes.

## Exercise: Preventing Data Loss
```{code-cell} bash
git switch feature
echo -en "\nThis is the fifth line." >> file1.txt
git switch main
```

```{admonition} What to notice
:class: hint
Git will not allow branch switching with uncommitted changes to protect against data loss.
```

## Note on Staging
Changes made after staging are not automatically included in the staged snapshot.

## Exercise: Staging and Modifying
```{code-cell} bash
git add file1.txt
echo -en "\nThis is the sixth line." >> file1.txt
git add file1.txt
git commit -m "Add fifth and sixth lines to file1.txt"
```

## Viewing All Commits
```{code-cell} bash
git switch main
git log --all
```

```{admonition} What to notice
:class: hint
Commits from `feature` are visible with `git log --all`, showing the comprehensive history across branches.
```

## Detached HEAD State
Exploring commits directly can lead to a detached HEAD state, which means you're no longer working on the tip of a branch.

## Creating and Switching Branches
Git offers shortcuts to create a new branch and switch to it in one operation, enhancing workflow efficiency.

```{code-cell} bash
git switch -c new-feature-branch
```
