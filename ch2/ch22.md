---
jupytext:
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.11.5
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---

```{code-cell} python
:tags: [remove-input]
import os
os.chdir('../home')
```

# 2.2 Debugging in Python with Visual Studio Code

## Sections 

- Introduction to debugging: importance and basic concepts.

- Configuration of the debugging environment in Visual Studio Code. 
- Use of breakpoints to halt execution.
 - Types of breakpoints: conditional and exception breakpoints. 
 - Inspection of variables and expressions during execution. 
 - Utilization of the debugging control panel. 
 - Step-by-step execution: step into, step over, and step out. 
 - Visualization tools: watch, variables, and call stack. 
 - Logging usage for debugging. 
 - Remote debugging and debugging in virtual environments. 
 - Using the justMyCode option to understand the behavior of third-party libraries. 
<!-- https://github.com/scikit-learn/scikit-learn/blob/6eff1757e/sklearn/linear_model/_coordinate_descent.py#L710 -->
<!-- In class, I can also show scikit-learn's code for the ElasticNet, in particular fit and from fit deep dive into -->
<!-- _validate_data. -->

## Motivation

Debugging is not merely about fixing errors; it's about understanding the behavior of your code under various conditions, ensuring reliability, and improving performance. Effective debugging can significantly reduce development time, enhance code quality, and create more robust applications.


Following the example develop in previuos chapter we have the important task of understanding and exploring the code checking if is robust enougth an analysing edge cases. For example:
- What happen if we pass a non-numeric type when we are inserting how much some person pays?

 Here is when the debugger comes in acction.

## Setting Up and Running the Debugger

1. **Open your Python script in VS Code** and make sure you have the Python extension installed. To install it, you can use the command: `code --install-extension ms-python.python`.

2. **Set the configuration file** `launch.json` in the `.vscode` folder. There, we can specify, for example, which Python version to use for debugging, which terminal to use, and many other specific configurations related to debugging.
In this case, we need a workaround to pass an argument to our code through the terminal while running in debug mode. So, we set the following configuration:
```
{
    "configurations": [
        {
            "name": "Python Debugger: expense splitter",
            "type": "debugpy",
            "request": "launch",
            "program": "${file}",
            "console": "integratedTerminal",
            "args": [
                "${input:expensesArg}"
            ]
        }
    ],
    "inputs": [
        {
            "id": "expensesArg",
            "type": "promptString",
            "description": "Enter the expenses argument (e.g. {\"Alice\":[34,2,3,45],\"Bob\":[3,4,26],\"Carol\":[10,20]})"
        }
    ]
}
```

2. **Open the Debug view** by clicking on the Run and Debug view icon on the left sidebar or pressing `Ctrl+Shift+D`. Select a Python interpreter if prompted. Select `Python Debugger` and select `Python File`.
4. **Start debugging** by selecting the appropriate Python file configuration and pressing the green play button or pressing `F5`. Make sure the "Raised Exceptions" option is ticked in the Breakpoints panel.

## Observing the Exception and Inspecting Variables
For this section we will be working with the first example: 
- What happen if we pass a non-numeric type when we are inserting how much some person pays?

So, to demonstrate this, we are going to insert `{"Alice": [34, 2, 3, 5], "Bob": [3, 4, 'a'], "Carol": [10, 20]}` as an argument when the debugger prompts for it.

The debugger normally runs the code and allows us to iteract with the program througth the debugger terminal, but it will halt execution when it encounters the uncaught TypeError exception due to attempting to convert a non numeric character to float. This halting point allows us to inspect the program's state just before the exception occurred.


- **Inspect the `amounts` variables** in the Variables panel to notice that the value for is the non numeric character.


## One liners and debugger

The debugger executes code line by line, which makes it difficult to be precise about where to pause execution when you have one-liners, such as list comprehensions, instead of for loops. Therefore, when we need to debug, it can be a good idea to refactor the code, changing one-liners to equivalent expressions that allow us to iterate more comfortably. With that expressions like: 


``` Python
    total_paid = {person: sum(amounts) for person, amounts in expenses.items()}
```

can be difficult to debug. Sometimes, it's better to write more breakable lines of code, like:

``` Python
  
    total_paid = {}

    for person, amounts in expenses.items():

        total_paid[person] = sum(amounts)
```

So, I asked Copilot to modify the code by replacing the dictionary comprehension with a for loop. Please do the same in your script.

## Setting a Breakpoint and Watching Variables

With the knowledge that our program halts due to a TypeError, we'll focus on the calculation of `total_paid`:

1. **Add a breakpoint** at the `total_paid[person] = sum(amounts)` line.
2. **Add `amounts` and `person` to the Watch panel** to monitor their values in real-time.
3. **Restart the debugger** and observe as it stops at our breakpoint before the exception occurs.
4. **Step through the for loop** using the "Step Over" button (or pressing `F10`) to iterate through each person and amounts.


## Identifying and testing a solution for the Issue

As you step through each iteration, if you input a non-numerical value, youâ€™ll notice in the Watch panel that 
`amounts` holds a value that cannot be converted into a number.
This is the moment of realization: the data type inconsistency is what's causing the issue.

1. **Modify the `amounts` variable directly in the Watch panel** by right-clicking and selecting "Change Value" to correct a non-numeric entry to a numeric one (e.g., an integer). For example, change the value "a" in the expenses list to 10, so you go from [3, 4, 'a'] to [3, 4, 10].
2. **Continue execution** by pressing the "Continue" button (or pressing `F5`) in the debugger.
3. Observe that the debugger now completes the execution without halting on an exception, and the correct total sales value is printed to the console.

## Other Types of Breakpoints
In our first example, we used an uncaught exception breakpoint to halt the execution of our program. Let's now use our example to explore other types of breakpoints.

### Conditional Breakpoints

Conditional Breakpoints pause execution when a specified condition is true.

1. Open your code in Visual Studio Code and navigate to the `for` loop line.
2. Right-click on the left margin and select "Add Conditional Breakpoint."
3. Enter `person == 'Bob'` as the condition.This setup ensures the debugger halts whenever the `person` variable is assigned to `Bob`, allowing you to inspect variables at that specific point in execution.

### Hit Count Breakpoints

Hit Count Breakpoints trigger after the breakpoint has been hit a specified number of times.

1. On the same line as before, add a breakpoint.
2. Right-click on the breakpoint and select "Edit Breakpoint" -> "Hit Count."
3. Specify the hit count as `2`. The debugger will now pause execution the third time it reaches this line, useful for examining the  `total_paid` dictionary after several iterations.

### Logpoints

Logpoints are used to log messages to the debug console without stopping the program.

1. Right-click on line `per_person_share = total_expense / len(participants)`, right after defining the balance in the for loop.  
2. Type `the total expenses are {total_expense} and the amount of participants are {len(participants)}` in the message field. This action allows real-time monitoring without the need of using prints. 

Logpoints are a clean alternative to using print statements for debugging.


```{admonition} Keep in mind
:class: note 
- You must be in the Debug Console to see these log messages.
```



### Function Breakpoints

1. In the Debug view under Breakpoints, click on "Add Function Breakpoint" and type the name of the function, `print_summary`.
2. When you run the debugger, it will pause every time `print_summary` is invoked, allowing you to inspect the initial state of the function and its parameters.



```{admonition} Why functions?  

- Improves code organization and readability.  
- Makes debugging easier by isolating functionality into functions or modules.  
- Encourages code reusability, reducing duplication.  
- Simplifies unit testing by focusing on smaller, well-defined parts.  
```

### Handling Exceptions

In our first example, we showed how the debugger can halt execution when an exception is raised.
Let's now explore how to configure the debugger to pause execution only when an unhandled exception is raised.
To do this, we need to ensure that only the "Uncaught Exceptions" option is checked in the Breakpoints panel.

1. First, we will try using a caught exception with the `Raised Exceptions` breakpoint selected.
Our testing argument will be `NoTValidadInputFormat`, and we will see that an exception for invalid input is raised.
Second, we will run the same scenario, but this time without selecting the `Raised Exceptions` breakpoint.

2. If we run the debugger now, since the exception is handled, the debugger will not pause when the ValueError is raised.
In this case, the code will break later because the default behavior of sys.exit(1) is to raise an unhandled exception.
### Function Breakpoints and Debugging Inside a Third-Party Library

Suppose we are working on a Python project that uses pandas for data manipulation and we have the following code:

```{code-block} python
import pandas as pd
s = pd.Series([1, 2, 3, 4])
s.add_suffix('_item')
```

We want to understand how the `add_suffix` method works internally, in particular, we would like to investigate an issue that occurs with `_get_axis_name` which is another method that is used by `add_suffix` (see source code [here](https://github.com/pandas-dev/pandas/blob/v2.2.1/pandas/core/generic.py#L4972-L5043)). To do this, we'll configure our debugger to step into the pandas library code and break when it reaches the `_get_axis_name` function.

#### Step 1: Configuring the Debugger

1. **Open VS Code** and navigate to your Python script.
2. **Open the `launch.json` file** in the `.vscode` folder. If it doesn't exist, create it by going to the Run and Debug view, selecting "create a launch.json file", and then choosing a Python configuration.
3. **Modify the `launch.json` file** to include the `justMyCode` option set to `false`. This tells the debugger to include third-party library code in the debugging session.

```json
{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Python Debugger: Current File",
            "type": "debugpy",
            "request": "launch",
            "program": "${file}",
            "console": "integratedTerminal",
            "justMyCode": false
        }
    ]
}
```

#### Step 2: Setting a Function Breakpoint

1. **Go to the Run and Debug view** in VS Code.
2. **Open the Breakpoints panel** and find the option to add a function breakpoint. Click on "Add Function Breakpoint".
3. **Type the name of the function** you want to break on. In this case, enter `_get_axis_name`.
4. **Start the debugger** by selecting the appropriate configuration for the current file and pressing the green play button or pressing `F5`.

#### What to Expect

When you run the debugger with these settings and execute your script, the debugger will pause execution when it reaches the `_get_axis_name` function call within the pandas library. This allows you to:

- Step through the pandas library code to see how the `_get_axis_name` function is implemented.
- Inspect variables and understand the internal workings of the function.
- Gain insights into the behavior of third-party libraries, which can be invaluable for debugging complex issues or enhancing your understanding of these libraries.

```{admonition} Keep in mind
:class: note 
- Stepping into third-party library code can sometimes be overwhelming due to the complexity and volume of the code. However, it can also be a powerful way to learn more about these libraries and to troubleshoot issues more effectively or even adapt them to your specific needs.
```

## References
https://code.visualstudio.com/docs/python/python-quick-start
https://code.visualstudio.com/docs/python/debugging
