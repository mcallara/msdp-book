---
jupytext:
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.11.5
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---

```{code-cell} python
:tags: [remove-input]
import os
os.chdir('../home')
```
- # 2.1 Debugging 

- ## Sections 

- Introduction to debugging: importance and basic concepts.

- Configuration of the debugging environment in Visual Studio Code. 
- Use of breakpoints to halt execution.
 - Types of breakpoints: conditional and exception breakpoints. 
 - Inspection of variables and expressions during execution. 
 - Utilization of the debugging control panel. 
 - Step-by-step execution: step into, step over, and step out. 
 - Visualization tools: watch, variables, and call stack. 
 - Logging usage for debugging. 
 - Remote debugging and debugging in virtual environments. 
 - Using the justMyCode option to understand the behavior of third-party libraries. 
<!-- https://github.com/scikit-learn/scikit-learn/blob/6eff1757e/sklearn/linear_model/_coordinate_descent.py#L710 -->
<!-- In class, I can also show scikit-learn's code for the ElasticNet, in particular fit and from fit deep dive into -->
<!-- _validate_data. -->

# 2.1 Debugging in Python with Visual Studio Code

## Motivation

Debugging is not merely about fixing errors; it's about understanding the behavior of your code under various conditions, ensuring reliability, and improving performance. Effective debugging can significantly reduce development time, enhance code quality, and create more robust applications.

Imagine you're working on a Python project that helps you split expenses with your friends using a command-line interface (CLI). So, you prompt your favorite LLM with:

```{admonition} Prompt
:class: Prompt
# TODO insert used prompt
```

And your favorite LLM returns you a new file called `expense_splitter.py` that has the folowing code on it: 

```{code-block} python
def main():
    print("Friends Expense Splitter")
    num_participants = int(input("How many participants? "))
    participants = []
    balances = {}
    for _ in range(num_participants):
        name = input("Enter participant name: ")
        participants.append(name)
        balances[name] = 0.0

    while True:
        cmd = input("Add expense? (y/n) ").lower()
        if cmd != 'y':
            break
        payer = input("Who paid? ")
        amount = input("How much? ")
        amount =  float(amount)  
        if payer in balances:
            balances[payer] += amount

    total_expenses = 0
    for value in balances.values():
        total_expenses += value
    print(f"Total expenses: {total_expenses:.2f}")
    share = total_expenses / len(participants)
    print("\nExpense Summary:")
    for name in participants:
        balance = balances[name] - share
        if balance > 0:
            print(f"{name} should receive {balance:.2f}")
        elif balance < 0:
            print(f"{name} should pay {-balance:.2f}")
        else:
            print(f"{name} is settled")

if __name__ == "__main__":
    main()
```

Now we have the important task of understanding and exploring the code checking if is robust enougth an analysing edge cases. For example:
- What happen if we pass a non-numeric type when we are inserting how much some person pays?
- What happen if we split the expensive with someone that is not in the list?

 Here is when the debugger comes in acction.

## Setting Up and Running the Debugger

1. **Open your Python script in VS Code** and make sure you have the Python extension installed. To install it, you can use the command: `code --install-extension ms-python.python`.
2. **Open the Debug view** by clicking on the Run and Debug view icon on the left sidebar or pressing `Ctrl+Shift+D`. Select a Python interpreter if prompted. Select `Python Debugger` and select `Python File`.
4. **Start debugging** by selecting the appropriate Python file configuration and pressing the green play button or pressing `F5`. Make sure the "Raised Exceptions" option is ticked in the Breakpoints panel.

## Observing the Exception and Inspecting Variables
For this section we will be working with the first example: 
- What happen if we pass a non-numeric type when we are inserting how much some person pays?

The debugger normally runs the code and allows us to iteract with the program througth the debugger terminal, but it will halt execution when it encounters the uncaught TypeError exception due to attempting to convert a non numeric character to float. This halting point allows us to inspect the program's state just before the exception occurred.


- **Inspect the `amount` variable** in the Variables panel to notice that the value for is the non numeric character and 

```{admonition} Tip
:class: tip
- Nested simple lines of code such as:
    ```python
    amount = float(input("How much? "))
    ```
  can be difficult to debug. Sometimes, it's better to write more breakable lines of code, like:
    ```python
    amount = input("How much? ")
    amount = float(amount)
    ```
```


## Setting a Breakpoint and Watching Variables

With the knowledge that our program halts due to a TypeError, we'll focus on the calculation of `amount`:

1. **Add a breakpoint** at the `amount =  float(amount)` line.
2. **Add `amount` and `balance` to the Watch panel** to monitor their values in real-time.
3. **Restart the debugger** and observe as it stops at our breakpoint before the exception occurs.
4. **Step through the for loop** using the "Step Over" button (or pressing `F10`) to iterate through each category and sale.


## Identifying and testing a solution for the Issue

As you step through each iteration, if you input a non-numerical value, you’ll notice in the Watch panel that 
`amount` holds a value that cannot be converted into a float.
This is the moment of realization: the data type inconsistency is what's causing the issue.

1. **Modify the `amount` directly in the watch panel** with a right-click and selecting "Change Value" to correct it from a non-numeric type to a numeric one (e.g., an integer).
2. **Continue execution** by pressing the "Continue" button (or pressing `F5`) in the debugger.
3. Observe that the debugger now completes the execution without halting on an exception, and the correct total sales value is printed to the console.

## Other Types of Breakpoints
In our first example, we used an uncaught exception breakpoint to halt the execution of our program. Let's now use our example to explore other types of breakpoints.

### Conditional Breakpoints

Conditional Breakpoints pause execution when a specified condition is true.

1. Open your code in Visual Studio Code and navigate to the `for` loop line.
2. Right-click on the left margin and select "Add Conditional Breakpoint."
3. Enter name == '`name_value`' as the condition, where `name_value` is the name you provided as input. This setup ensures the debugger halts whenever the name variable is assigned that value, allowing you to inspect variables at that specific point in execution.

### Hit Count Breakpoints

Hit Count Breakpoints trigger after the breakpoint has been hit a specified number of times.

1. On the same line as before, add a breakpoint.
2. Right-click on the breakpoint and select "Edit Breakpoint" -> "Hit Count."
3. Specify the hit count as `3`. The debugger will now pause execution the third time it reaches this line, useful for examining the accumulated `total_expenses` after several iterations.

### Logpoints

Logpoints are used to log messages to the debug console without stopping the program.

1. Right-click on line 29, right after defining the balance in the for loop.  
2. Type `The balance of {name} is {balance}` in the message field. This action allows real-time monitoring of each participant’s balance.

Logpoints are a clean alternative to using print statements for debugging.


```{admonition} Keep in mind
:class: note 
- You must be in the Debug Console to see these log messages.
```



### Function Breakpoints

Function breakpoints halt execution when entering a specified function.

1. In the Debug view under Breakpoints, click on "Add Function Breakpoint" and type the name of the function, `calculate_total_sales`.
2. When you run the debugger, it will pause every time `calculate_total_sales` is invoked, allowing you to inspect the initial state of the function and its parameters.


### Handling Exceptions

In our first example, we shown how the debugger can halt execution when an exception is raised. Let's now explore how to configure the debugger to pause execution only when a not handled exception is raised.

To see this in action let's replace our `calculate_total_sales`, with the following code:
    
```{code-block} python
def calculate_total_sales(sales_data):
    total_sales = 0
    for category, sales in sales_data.items():
        try:
            total_sales += sales
        except TypeError:
            print(f"Invalid sales data for {category}: {sales}")
    return total_sales
```

In this modified version, we've added a try-except block to handle the TypeError exception. We'll now configure the debugger to pause only when an exception is raised and not handled. To do this, we need to ensure that only the "Uncaught Exceptions" option is checked in the Breakpoints panel.

Now, if we run the debugger, since the exception is handled, the debugger will not pause when the TypeError exception is raised. However, if we remove the try-except block, the debugger will pause when the exception is raised.

```{admonition} Test your knowledge
:class: tip 
 - Clone the debugging exercise with the command `git clone git@gitlab.com:msdp.book/debbuging-exercise-1.git`
 - Find the bug.
```
### Function Breakpoints and Debugging Inside a Third-Party Library

Suppose we are working on a Python project that uses pandas for data manipulation and we have the following code:

```{code-block} python
import pandas as pd
s = pd.Series([1, 2, 3, 4])
s.add_suffix('_item')
```

We want to understand how the `add_suffix` method works internally, in particular, we would like to investigate an issue that occurs with `_get_axis_name` which is another method that is used by `add_suffix` (see source code [here](https://github.com/pandas-dev/pandas/blob/v2.2.1/pandas/core/generic.py#L4972-L5043)). To do this, we'll configure our debugger to step into the pandas library code and break when it reaches the `_get_axis_name` function.

#### Step 1: Configuring the Debugger

1. **Open VS Code** and navigate to your Python script.
2. **Open the `launch.json` file** in the `.vscode` folder. If it doesn't exist, create it by going to the Run and Debug view, selecting "create a launch.json file", and then choosing a Python configuration.
3. **Modify the `launch.json` file** to include the `justMyCode` option set to `false`. This tells the debugger to include third-party library code in the debugging session.

```json
{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Python Debugger: Current File",
            "type": "debugpy",
            "request": "launch",
            "program": "${file}",
            "console": "integratedTerminal",
            "justMyCode": false
        }
    ]
}
```

#### Step 2: Setting a Function Breakpoint

1. **Go to the Run and Debug view** in VS Code.
2. **Open the Breakpoints panel** and find the option to add a function breakpoint. Click on "Add Function Breakpoint".
3. **Type the name of the function** you want to break on. In this case, enter `_get_axis_name`.
4. **Start the debugger** by selecting the appropriate configuration for the current file and pressing the green play button or pressing `F5`.

#### What to Expect

When you run the debugger with these settings and execute your script, the debugger will pause execution when it reaches the `_get_axis_name` function call within the pandas library. This allows you to:

- Step through the pandas library code to see how the `_get_axis_name` function is implemented.
- Inspect variables and understand the internal workings of the function.
- Gain insights into the behavior of third-party libraries, which can be invaluable for debugging complex issues or enhancing your understanding of these libraries.

```{admonition} Keep in mind
:class: note 
- Stepping into third-party library code can sometimes be overwhelming due to the complexity and volume of the code. However, it can also be a powerful way to learn more about these libraries and to troubleshoot issues more effectively or even adapt them to your specific needs.
```

## References
https://code.visualstudio.com/docs/python/python-quick-start
https://code.visualstudio.com/docs/python/debugging
https://code.visualstudio.com/docs/editor/debugging